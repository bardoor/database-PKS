import mysql.connector
from abc import ABC


class Table(ABC):
    @staticmethod
    def add(values: dict):
        ...

    @staticmethod
    def find(values: dict):
        ...

    @staticmethod
    def get_fields_name():
        ...

    @staticmethod
    def delete(values: dict):
        ...

    @staticmethod
    def update(values: dict):
        ...


class DateBase:
    __cursor = None
    __connection = None

    @classmethod
    def connect(cls, host, user, password, database):
        cls.__connection = mysql.connector.connect(
            user=user, password=password,
            host=host, database=database
        )
        cls.__cursor = cls.__connection.cursor()

    @classmethod
    def cursor(cls):
        return cls.__cursor

    @classmethod
    def commit(cls):
        cls.__connection.commit()


class BooksTable(Table):
    @staticmethod
    def get_by_id(values: dict):
        id = values["id"]
        query = "SELECT * FROM Books WHERE id = %s;"
        DateBase.cursor().execute(query, (id,))
        All_info = DateBase().cursor().fetchall()
        return All_info

    def get_by_price(values: dict):
        price = values["price"]
        query = "SELECT * FROM Books WHERE price = %s;"
        DateBase.cursor().execute(query, (price,))
        price = DateBase().cursor().fetchall()
        return price

    def get_by_name(name: str):
        query = "SELECT * FROM Books WHERE name = %s;"
        DateBase.cursor().execute(query, (name,))
        name = DateBase().cursor().fetchall()
        return name

    def add(values: dict):
        price, name = values["price"], values["name"]
        query = "INSERT INTO Books (price, name) VALUES(%s, %s);"
        DateBase.cursor().execute(query, (price, name))

    def get_fields_name():
        return ["price", "name"]

    def find(values: dict):
        name = values["name"] if "name" in values else None
        price = values["price"] if "price" in values else None
        (sort_col, asc) = values["sort"] if "sort" in values else None
        limit = values["limit"] if "limit" in values else None
        params = []

        if name is not None and price is not None:
            query = "SELECT name, price FROM Books WHERE name = %s AND price = %s"
            DateBase.cursor().execute(query, (name, price,))
            params += [name, price]
        elif name is not None and price is None:
            query = "SELECT name, price FROM Books WHERE name = %s"
            DateBase.cursor().execute(query, (name,))
            params += [name]
        elif name is None and price is not None:
            query = "SELECT name, price FROM Books WHERE price = %s"
            DateBase.cursor().execute(query, (price,))
            params += [price]
        else:
            query = "SELECT * FROM Books"

        if asc == "Y":
            asc = True
        else:
            asc = False

        query += f" ORDER BY {sort_col} {'ASC' if asc else 'DESC'};"

        query += f"LIMIT {limit};"

        DateBase.cursor().fetchall()

        DateBase.cursor().execute(query, params)

        return DateBase.cursor().fetchall()

    def delete(values: dict):
        name = values['name']
        query = "DELETE FROM Books WHERE name = %s;"
        DateBase.cursor().execute(query, (name,))
        DateBase.commit()

    def update(values: dict):
        name_column = values['name_column']
        new_value = values['new_value']
        condition_column = values['condition_column']
        condition_value = values['condition_value']

        query = f""" UPDATE Books SET `{name_column}` = %s WHERE `{condition_column}` = %s; """

        DateBase.cursor().execute(query, (new_value, condition_value))
        DateBase.commit()


class AddressTable(Table):
    def get_by_id(id: int):
        query = "SELECT * FROM Address WHERE id = %s;"
        DateBase.cursor().execute(query, (id,))
        all_info = DateBase.cursor().fetchall()
        return all_info

    def get_by_address(address):
        query = "SELECT address FROM Address WHERE address = `%s`;"
        DateBase.cursor().execute(query, (address,))
        address = DateBase.cursor().fetchall()
        return address

    def add(values: dict):
        address, city = values["address"], values["city"]
        query = "INSERT INTO Address (address, city) VALUES(%s, %s);"
        DateBase.cursor().execute(query, (address, city))

    def get_fields_name():
        return ["address", "city"]

    def delete(values: dict):
        address = values["name"]
        query = f"DELETE FROM Address WHERE address = %s;"
        DateBase.cursor().execute(query, (address,))
        DateBase.commit()

    def update(values: dict):
        name_column = values['name_column']
        new_value = values['new_value']
        condition_column = values['condition_column']
        condition_value = values['condition_value']

        query = f""" UPDATE Address SET `{name_column}` = %s WHERE `{condition_column}` = %s; """

        DateBase.cursor().execute(query, (new_value, condition_value))
        DateBase.commit()


class Program:
    __is_finished: bool = False
    __current_table: Table

    @classmethod
    def __handle_table_choice(cls):
        print("1: Работать с таблицей Books")
        print("2: Работать с таблицей Address")

        choice = int(input(">> "))
        if choice == 1:
            cls.__current_table = BooksTable
        elif choice == 2:
            cls.__current_table = AddressTable

    @classmethod
    def __handle_choice(cls):
        print(f"1: Добавить запись")
        print(f"2: Удалить запись")
        print(f"3: Найти запись")
        print(f"4: Сохранить изменения")
        print(f"5: Изменить данные")
        print(f"6: Выход")

        choice = int(input(">> "))
        if choice == 1:
            field_names = cls.__current_table.get_fields_name()
            values = dict()

            for field_name in field_names:
                values[field_name] = input(f"{field_name}: ")

            cls.__current_table.add(values)
            print("Запись успешно добавлена!")

        elif choice == 2:
            field_names = cls.__current_table.get_fields_name()
            values = dict()

            values['name'] = input("name:  ")
            cls.__current_table.delete(values)
            print("Успешно удалена запись!")

        elif choice == 3:
            values = dict()
            values["name"] = input("name:  ")
            values["price"] = input("price:  ")

            if values["price"] == "":
                values["price"] = None

            if values["name"] == "":
                values["name"] = None


            values["sort"] = [input("sort_col: ")]
            values["sort"] += [input("asc: ")]

            values["limit"] = input("limit:  ")
            field_names = cls.__current_table.find(values)
            print(field_names)

        elif choice == 4:
            DateBase.commit()
            print("Изменения успешно сохранены")

        elif choice == 5:
            values = dict()
            values["name_column"], values["new_value"], values["condition_column"], values["condition_value"] = input(
                "Название Столбца:   "), input("Новое значние:   "), input("Условие, Значение стобца:   "), input(
                "Условие, Значение строки:   ")
            cls.__current_table.update(values)
            DateBase.commit()
            print("Изменения успешно сохранены")

        elif choice == 6:
            cls.__is_finished = True

    @classmethod
    def main(cls):
        DateBase.connect(
            host="109.206.169.221",
            user="seschool_01",
            password="seschool_01",
            database="seschool_01"
        )
        while not cls.__is_finished:
            cls.__handle_table_choice()
            cls.__handle_choice()


Program.main()
