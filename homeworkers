import mysql.connector
from abc import ABC


class Table(ABC):
    @staticmethod
    def add(values: dict):
        ...

    @staticmethod
    def find(values: dict):
        ...

    @staticmethod
    def get_fields_name():
        ...

    @staticmethod
    def del_record():
        ...

    @staticmethod
    def update():
        ...


class DateBase:
    __cursor = None
    __connection = None

    @classmethod
    def connect(cls, host, user, password, database):
        cls.__connection = mysql.connector.connect(
            user=user, password=password,
            host=host, database=database
        )
        cls.__cursor = cls.__connection.cursor()

    @classmethod
    def cursor(cls):
        return cls.__cursor

    @classmethod
    def commit(cls):
        cls.__connection.commit()



class BooksTable(Table):
    @staticmethod
    def get_by_id(values: dict):
        id = values["id"]
        query = "SELECT * FROM Books WHERE id = %s;"
        DateBase.cursor().execute(query, (id,))
        All_info = DateBase().cursor().fetchall()
        return All_info

    def get_by_price(values: dict):
        price = values["price"]
        query = "SELECT * FROM Books WHERE price = %s;"
        DateBase.cursor().execute(query, (price,))
        price = DateBase().cursor().fetchall()
        return price

    def get_by_name(name: str):
        query = "SELECT * FROM Books WHERE name = %s;"
        DateBase.cursor().execute(query, (name,))
        name = DateBase().cursor().fetchall()
        return name

    def add(values: dict):
        price, name = values["price"], values["name"]
        query = "INSERT INTO Books (price, name) VALUES(%s, %s);"
        DateBase.cursor().execute(query, (price, name))

    def get_fields_name():
        return ["price", "name"]

    def find(values: dict):
        name = values["name"]
        query = "SELECT * FROM Books WHERE name = %s;"
        DateBase.cursor().execute(query, (name,))
        all_name = DateBase().cursor().fetchall()
        print(all_name)

    def del_record(values: dict):
        new_value = values["new_value"]
        name_column = values['name_column']
        query = f"DELETE FROM Books WHERE `{name_column}` = %s;"
        DateBase.cursor().execute(query, (new_value,))
        DateBase.commit()

    def update(values: dict):
        name_column = values['name_column']
        new_value = values['new_value']
        condition_column = values['condition_column']
        condition_value = values['condition_value']

        query = f""" UPDATE Books SET `{name_column}` = %s WHERE `{condition_column}` = %s; """

        DateBase.cursor().execute(query, (new_value, condition_value))
        DateBase.commit()


class AddressTable(Table):
    def get_by_id(id: int):
        query = "SELECT * FROM Address WHERE id = %s;"
        DateBase.cursor().execute(query, (id,))
        all_info = DateBase.cursor().fetchall()
        return all_info

    def get_by_address(address):
        query = "SELECT address FROM Address WHERE address = `%s`;"
        DateBase.cursor().execute(query, (address,))
        address = DateBase.cursor().fetchall()
        return address

    def add(values: dict):
        address, city = values["address"], values["city"]
        query = "INSERT INTO Address (address, city) VALUES(%s, %s);"
        DateBase.cursor().execute(query, (address, city))

    def get_fields_name():
        return ["address", "city"]

    def del_record(values: dict):
        new_value = values["new_value"]
        name_column = values['name_column']
        query = f"DELETE FROM Address WHERE `{name_column}` = %s;"
        DateBase.cursor().execute(query, (new_value,))
        DateBase.commit()

    def update(values: dict):
        name_column = values['name_column']
        new_value = values['new_value']
        condition_column = values['condition_column']
        condition_value = values['condition_value']

        query = f""" UPDATE Address SET `{name_column}` = %s WHERE `{condition_column}` = %s; """

        DateBase.cursor().execute(query, (new_value, condition_value))
        DateBase.commit()

class Program:
    __is_finished: bool = False
    __current_table: Table

    @classmethod
    def __handle_table_choice(cls):
        print("1: Работать с таблицей Books")
        print("2: Работать с таблицей Address")

        choice = int(input(">> "))
        if choice == 1:
            cls.__current_table = BooksTable
        elif choice == 2:
            cls.__current_table = AddressTable

    @classmethod
    def __handle_choice(cls):
        print(f"1: Добавить запись")
        print(f"2: Удалить запись")
        print(f"3: Найти запись")
        print(f"4: Сохранить изменения")
        print(f"5: Изменить данные")
        print(f"6: Выход")

        choice = int(input(">> "))
        if choice == 1:
            field_names = cls.__current_table.get_fields_name()
            values = dict()

            for field_name in field_names:
                values[field_name] = input(f"{field_name}: ")

            cls.__current_table.add(values)
            print("Запись успешно добавлена!")

        elif choice == 2:
            values = dict()
            values['name_column'] = input("column:  ")
            values["new_value"] = input("new_value:  ")
            cls.__current_table.del_record(values)
            print("Успешно удалена запись!")

        elif choice == 3:
            values = dict()
            values["name"] = input("name:  ")
            field_names = cls.__current_table.find(values)
            print(field_names)

        elif choice == 4:
            DateBase.commit()
            print("Изменения успешно сохранены")

        elif choice == 5:
            values = dict()
            values["name_column"], values["new_value"], values["condition_column"], values["condition_value"] = input("Название Столбца:   "), input("Новое значние:   "), input("Условие, Значение стобца:   "), input("Условие, Значение строки:   ")
            cls.__current_table.update(values)
            DateBase.commit()
            print("Изменения успешно сохранены")

        elif choice == 6:
            cls.__is_finished = True


    @classmethod
    def main(cls):
        DateBase.connect(
            host="109.206.169.221",
            user="seschool_01",
            password="seschool_01",
            database="seschool_01"
        )
        while not cls.__is_finished:
            cls.__handle_table_choice()
            cls.__handle_choice()
            DateBase.commit()


Program.main()
